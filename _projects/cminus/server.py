from flask import Flask, request, jsonify
from flask_cors import CORS
import subprocess
import os

app = Flask(__name__)
# 允许所有来源
CORS(app)

@app.route('/compile_and_run', methods=['POST'])
def compile_and_run():
    try:
        # Step 1: Get the code from the request
        code = request.json.get('code')
        if not code:
            return jsonify({'error': 'No code provided'}), 400
        if len(code) > 100000:
            return jsonify({'error': 'Code is too long'}), 400

        # Step 2: Save the code to a file named code.cminus
        code_file = 'code.cminus'
        with open(code_file, 'w') as f:
            f.write(code)

        # Step 3: Run the ./compiler program
        compiler_command = ['./cminusfc', code_file, '-emit-llvm']
        try:
            result = subprocess.run(compiler_command, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                return jsonify({'error': result.stderr}), 500
        except subprocess.TimeoutExpired:
            return jsonify({'error': 'Compiler timed out'}), 500

        expected_files = ['code.ll', 'code.s', 'after_Mem2Reg.ll', 'after_LIR.ll']
        for file in expected_files:
            if not os.path.exists(file):
                return jsonify({'error': f'{file} not generated by compiler'}), 500

        # Step 4: Compile the code using riscv64-linux-gnu-gcc
        gcc_command = ['riscv64-linux-gnu-gcc', 'code.s', 'io.o', '-o', 'test']
        result = subprocess.run(gcc_command, capture_output=True, text=True)
        if result.returncode != 0:
            return jsonify({'error': result.stderr}), 500

        # Step 5: Run the generated executable using qemu-riscv64
        try:
            qemu_command = ['qemu-riscv64', '-L', '/usr/riscv64-linux-gnu', './test']
            result = subprocess.run(qemu_command, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                return jsonify({'error': result.stderr}), 500
        except subprocess.TimeoutExpired:
            return jsonify({'error': 'qemu-riscv64 timed out'}), 500

        with open('code.s', 'r') as f:
            result.code_s = f.read()
        with open('code.ll', 'r') as f:
            result.code_ll = f.read()
        with open('after_Mem2Reg.ll', 'r') as f:
            result.after_Mem2Reg_ll = f.read()
        with open('after_LIR.ll', 'r') as f:
            result.after_LIR_ll = f.read()
        # Return the output from the QEMU execution
        return jsonify({'output': result.stdout, 'code.s': result.code_s,
                        'code.ll': result.code_ll, 'after_Mem2Reg.ll': result.after_Mem2Reg_ll,
                        'after_LIR.ll': result.after_LIR_ll})

    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
